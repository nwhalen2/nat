{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/createClass\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\nvar _ParseCLP = _interopRequireDefault(require(\"./ParseCLP\"));\n/**\n * @flow\n */\n\nvar FIELD_TYPES = ['String', 'Number', 'Boolean', 'Date', 'File', 'GeoPoint', 'Polygon', 'Array', 'Object', 'Pointer', 'Relation'];\n/*:: type FieldOptions = {\n  required: boolean,\n  defaultValue: mixed,\n};*/\n\n/**\n * A Parse.Schema object is for handling schema data from Parse.\n * <p>All the schemas methods require MasterKey.\n *\n * When adding fields, you may set required and default values. (Requires Parse Server 3.7.0+)\n *\n * <pre>\n * const options = { required: true, defaultValue: 'hello world' };\n * const schema = new Parse.Schema('MyClass');\n * schema.addString('field', options);\n * schema.addIndex('index_name', { 'field': 1 });\n * schema.save();\n * </pre>\n * </p>\n *\n * @alias Parse.Schema\n */\n\nvar ParseSchema = /*#__PURE__*/function () {\n  /**\n   * @param {string} className Parse Class string.\n   */\n  function ParseSchema(className\n  /*: string*/) {\n    (0, _classCallCheck2.default)(this, ParseSchema);\n    (0, _defineProperty2.default)(this, \"className\", void 0);\n    (0, _defineProperty2.default)(this, \"_fields\", void 0);\n    (0, _defineProperty2.default)(this, \"_indexes\", void 0);\n    (0, _defineProperty2.default)(this, \"_clp\", void 0);\n    if (typeof className === 'string') {\n      if (className === 'User' && _CoreManager.default.get('PERFORM_USER_REWRITE')) {\n        this.className = '_User';\n      } else {\n        this.className = className;\n      }\n    }\n    this._fields = {};\n    this._indexes = {};\n  }\n  /**\n   * Static method to get all schemas\n   *\n   * @returns {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n\n  (0, _createClass2.default)(ParseSchema, [{\n    key: \"get\",\n    value:\n    /**\n     * Get the Schema from Parse\n     *\n     * @returns {Promise} A promise that is resolved with the result when\n     * the query completes.\n     */\n    function () {\n      this.assertClassName();\n      var controller = _CoreManager.default.getSchemaController();\n      return controller.get(this.className).then(function (response) {\n        if (!response) {\n          throw new Error('Schema not found.');\n        }\n        return response;\n      });\n    }\n    /**\n     * Create a new Schema on Parse\n     *\n     * @returns {Promise} A promise that is resolved with the result when\n     * the query completes.\n     */\n  }, {\n    key: \"save\",\n    value: function () {\n      this.assertClassName();\n      var controller = _CoreManager.default.getSchemaController();\n      var params = {\n        className: this.className,\n        fields: this._fields,\n        indexes: this._indexes,\n        classLevelPermissions: this._clp\n      };\n      return controller.create(this.className, params);\n    }\n    /**\n     * Update a Schema on Parse\n     *\n     * @returns {Promise} A promise that is resolved with the result when\n     * the query completes.\n     */\n  }, {\n    key: \"update\",\n    value: function () {\n      this.assertClassName();\n      var controller = _CoreManager.default.getSchemaController();\n      var params = {\n        className: this.className,\n        fields: this._fields,\n        indexes: this._indexes,\n        classLevelPermissions: this._clp\n      };\n      this._fields = {};\n      this._indexes = {};\n      return controller.update(this.className, params);\n    }\n    /**\n     * Removing a Schema from Parse\n     * Can only be used on Schema without objects\n     *\n     * @returns {Promise} A promise that is resolved with the result when\n     * the query completes.\n     */\n  }, {\n    key: \"delete\",\n    value: function () {\n      this.assertClassName();\n      var controller = _CoreManager.default.getSchemaController();\n      return controller.delete(this.className);\n    }\n    /**\n     * Removes all objects from a Schema (class) in Parse.\n     * EXERCISE CAUTION, running this will delete all objects for this schema and cannot be reversed\n     *\n     * @returns {Promise} A promise that is resolved with the result when\n     * the query completes.\n     */\n  }, {\n    key: \"purge\",\n    value: function () {\n      this.assertClassName();\n      var controller = _CoreManager.default.getSchemaController();\n      return controller.purge(this.className);\n    }\n    /**\n     * Assert if ClassName has been filled\n     *\n     * @private\n     */\n  }, {\n    key: \"assertClassName\",\n    value: function () {\n      if (!this.className) {\n        throw new Error('You must set a Class Name before making any request.');\n      }\n    }\n    /**\n     * Sets Class Level Permissions when creating / updating a Schema.\n     * EXERCISE CAUTION, running this may override CLP for this schema and cannot be reversed\n     *\n     * @param {object | Parse.CLP} clp Class Level Permissions\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n  }, {\n    key: \"setCLP\",\n    value: function (clp\n    /*: PermissionsMap | ParseCLP*/) {\n      if (clp instanceof _ParseCLP.default) {\n        this._clp = clp.toJSON();\n      } else {\n        this._clp = clp;\n      }\n      return this;\n    }\n    /**\n     * Adding a Field to Create / Update a Schema\n     *\n     * @param {string} name Name of the field that will be created on Parse\n     * @param {string} type Can be a (String|Number|Boolean|Date|Parse.File|Parse.GeoPoint|Array|Object|Pointer|Parse.Relation)\n     * @param {object} options\n     * Valid options are:<ul>\n     *   <li>required: If field is not set, save operation fails (Requires Parse Server 3.7.0+)\n     *   <li>defaultValue: If field is not set, a default value is selected (Requires Parse Server 3.7.0+)\n     *   <li>targetClass: Required if type is Pointer or Parse.Relation\n     * </ul>\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n  }, {\n    key: \"addField\",\n    value: function (name\n    /*: string*/, type\n    /*: string*/) {\n      var options\n      /*: FieldOptions*/ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      type = type || 'String';\n      if (!name) {\n        throw new Error('field name may not be null.');\n      }\n      if ((0, _indexOf.default)(FIELD_TYPES).call(FIELD_TYPES, type) === -1) {\n        throw new Error(\"\".concat(type, \" is not a valid type.\"));\n      }\n      if (type === 'Pointer') {\n        return this.addPointer(name, options.targetClass, options);\n      }\n      if (type === 'Relation') {\n        return this.addRelation(name, options.targetClass, options);\n      }\n      var fieldOptions = {\n        type: type\n      };\n      if (typeof options.required === 'boolean') {\n        fieldOptions.required = options.required;\n      }\n      if (options.defaultValue !== undefined) {\n        fieldOptions.defaultValue = options.defaultValue;\n      }\n      if (type === 'Date') {\n        if (options && options.defaultValue) {\n          fieldOptions.defaultValue = {\n            __type: 'Date',\n            iso: new Date(options.defaultValue)\n          };\n        }\n      }\n      this._fields[name] = fieldOptions;\n      return this;\n    }\n    /**\n     * Adding an Index to Create / Update a Schema\n     *\n     * @param {string} name Name of the index\n     * @param {object} index { field: value }\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n     *\n     * <pre>\n     * schema.addIndex('index_name', { 'field': 1 });\n     * </pre>\n     */\n  }, {\n    key: \"addIndex\",\n    value: function (name\n    /*: string*/, index\n    /*: any*/) {\n      if (!name) {\n        throw new Error('index name may not be null.');\n      }\n      if (!index) {\n        throw new Error('index may not be null.');\n      }\n      this._indexes[name] = index;\n      return this;\n    }\n    /**\n     * Adding String Field\n     *\n     * @param {string} name Name of the field that will be created on Parse\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n  }, {\n    key: \"addString\",\n    value: function (name\n    /*: string*/, options\n    /*: FieldOptions*/) {\n      return this.addField(name, 'String', options);\n    }\n    /**\n     * Adding Number Field\n     *\n     * @param {string} name Name of the field that will be created on Parse\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n  }, {\n    key: \"addNumber\",\n    value: function (name\n    /*: string*/, options\n    /*: FieldOptions*/) {\n      return this.addField(name, 'Number', options);\n    }\n    /**\n     * Adding Boolean Field\n     *\n     * @param {string} name Name of the field that will be created on Parse\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n  }, {\n    key: \"addBoolean\",\n    value: function (name\n    /*: string*/, options\n    /*: FieldOptions*/) {\n      return this.addField(name, 'Boolean', options);\n    }\n    /**\n     * Adding Date Field\n     *\n     * @param {string} name Name of the field that will be created on Parse\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n  }, {\n    key: \"addDate\",\n    value: function (name\n    /*: string*/, options\n    /*: FieldOptions*/) {\n      return this.addField(name, 'Date', options);\n    }\n    /**\n     * Adding File Field\n     *\n     * @param {string} name Name of the field that will be created on Parse\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n  }, {\n    key: \"addFile\",\n    value: function (name\n    /*: string*/, options\n    /*: FieldOptions*/) {\n      return this.addField(name, 'File', options);\n    }\n    /**\n     * Adding GeoPoint Field\n     *\n     * @param {string} name Name of the field that will be created on Parse\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n  }, {\n    key: \"addGeoPoint\",\n    value: function (name\n    /*: string*/, options\n    /*: FieldOptions*/) {\n      return this.addField(name, 'GeoPoint', options);\n    }\n    /**\n     * Adding Polygon Field\n     *\n     * @param {string} name Name of the field that will be created on Parse\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n  }, {\n    key: \"addPolygon\",\n    value: function (name\n    /*: string*/, options\n    /*: FieldOptions*/) {\n      return this.addField(name, 'Polygon', options);\n    }\n    /**\n     * Adding Array Field\n     *\n     * @param {string} name Name of the field that will be created on Parse\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n  }, {\n    key: \"addArray\",\n    value: function (name\n    /*: string*/, options\n    /*: FieldOptions*/) {\n      return this.addField(name, 'Array', options);\n    }\n    /**\n     * Adding Object Field\n     *\n     * @param {string} name Name of the field that will be created on Parse\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n  }, {\n    key: \"addObject\",\n    value: function (name\n    /*: string*/, options\n    /*: FieldOptions*/) {\n      return this.addField(name, 'Object', options);\n    }\n    /**\n     * Adding Pointer Field\n     *\n     * @param {string} name Name of the field that will be created on Parse\n     * @param {string} targetClass Name of the target Pointer Class\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n  }, {\n    key: \"addPointer\",\n    value: function (name\n    /*: string*/, targetClass\n    /*: string*/) {\n      var options\n      /*: FieldOptions*/ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (!name) {\n        throw new Error('field name may not be null.');\n      }\n      if (!targetClass) {\n        throw new Error('You need to set the targetClass of the Pointer.');\n      }\n      var fieldOptions = {\n        type: 'Pointer',\n        targetClass: targetClass\n      };\n      if (typeof options.required === 'boolean') {\n        fieldOptions.required = options.required;\n      }\n      if (options.defaultValue !== undefined) {\n        fieldOptions.defaultValue = options.defaultValue;\n        if (options.defaultValue instanceof _ParseObject.default) {\n          fieldOptions.defaultValue = options.defaultValue.toPointer();\n        }\n      }\n      this._fields[name] = fieldOptions;\n      return this;\n    }\n    /**\n     * Adding Relation Field\n     *\n     * @param {string} name Name of the field that will be created on Parse\n     * @param {string} targetClass Name of the target Pointer Class\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n  }, {\n    key: \"addRelation\",\n    value: function (name\n    /*: string*/, targetClass\n    /*: string*/) {\n      if (!name) {\n        throw new Error('field name may not be null.');\n      }\n      if (!targetClass) {\n        throw new Error('You need to set the targetClass of the Relation.');\n      }\n      this._fields[name] = {\n        type: 'Relation',\n        targetClass: targetClass\n      };\n      return this;\n    }\n    /**\n     * Deleting a Field to Update on a Schema\n     *\n     * @param {string} name Name of the field\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n  }, {\n    key: \"deleteField\",\n    value: function (name\n    /*: string*/) {\n      this._fields[name] = {\n        __op: 'Delete'\n      };\n      return this;\n    }\n    /**\n     * Deleting an Index to Update on a Schema\n     *\n     * @param {string} name Name of the field\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n  }, {\n    key: \"deleteIndex\",\n    value: function (name\n    /*: string*/) {\n      this._indexes[name] = {\n        __op: 'Delete'\n      };\n      return this;\n    }\n  }], [{\n    key: \"all\",\n    value: function () {\n      var controller = _CoreManager.default.getSchemaController();\n      return controller.get('').then(function (response) {\n        if (response.results.length === 0) {\n          throw new Error('Schema not found.');\n        }\n        return response.results;\n      });\n    }\n  }]);\n  return ParseSchema;\n}();\nvar DefaultController = {\n  send: function (className\n  /*: string*/, method\n  /*: string*/) /*: Promise*/\n  {\n    var params\n    /*: any*/ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request(method, \"schemas/\".concat(className), params, {\n      useMasterKey: true\n    });\n  },\n  get: function (className\n  /*: string*/) /*: Promise*/\n  {\n    return this.send(className, 'GET');\n  },\n  create: function (className\n  /*: string*/, params\n  /*: any*/) /*: Promise*/\n  {\n    return this.send(className, 'POST', params);\n  },\n  update: function (className\n  /*: string*/, params\n  /*: any*/) /*: Promise*/\n  {\n    return this.send(className, 'PUT', params);\n  },\n  delete: function (className\n  /*: string*/) /*: Promise*/\n  {\n    return this.send(className, 'DELETE');\n  },\n  purge: function (className\n  /*: string*/) /*: Promise*/\n  {\n    var RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request('DELETE', \"purge/\".concat(className), {}, {\n      useMasterKey: true\n    });\n  }\n};\n_CoreManager.default.setSchemaController(DefaultController);\nvar _default = ParseSchema;\nexports.default = _default;","map":{"version":3,"names":["_interopRequireDefault","require","_Object$defineProperty","exports","value","default","_indexOf","_classCallCheck2","_createClass2","_defineProperty2","_CoreManager","_ParseObject","_ParseCLP","FIELD_TYPES","ParseSchema","className","get","_fields","_indexes","key","assertClassName","controller","getSchemaController","then","response","Error","params","fields","indexes","classLevelPermissions","_clp","create","update","delete","purge","clp","toJSON","name","type","options","arguments","length","undefined","call","concat","addPointer","targetClass","addRelation","fieldOptions","required","defaultValue","__type","iso","Date","index","addField","toPointer","__op","results","DefaultController","send","method","RESTController","getRESTController","request","useMasterKey","setSchemaController","_default"],"sources":["/Users/nnwhalen/Desktop/NOTREDAME/web dev/node_modules/parse/lib/browser/ParseSchema.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _ParseCLP = _interopRequireDefault(require(\"./ParseCLP\"));\n/**\n * @flow\n */\n\n\nvar FIELD_TYPES = ['String', 'Number', 'Boolean', 'Date', 'File', 'GeoPoint', 'Polygon', 'Array', 'Object', 'Pointer', 'Relation'];\n/*:: type FieldOptions = {\n  required: boolean,\n  defaultValue: mixed,\n};*/\n\n/**\n * A Parse.Schema object is for handling schema data from Parse.\n * <p>All the schemas methods require MasterKey.\n *\n * When adding fields, you may set required and default values. (Requires Parse Server 3.7.0+)\n *\n * <pre>\n * const options = { required: true, defaultValue: 'hello world' };\n * const schema = new Parse.Schema('MyClass');\n * schema.addString('field', options);\n * schema.addIndex('index_name', { 'field': 1 });\n * schema.save();\n * </pre>\n * </p>\n *\n * @alias Parse.Schema\n */\n\nvar ParseSchema = /*#__PURE__*/function () {\n  /**\n   * @param {string} className Parse Class string.\n   */\n  function ParseSchema(className\n  /*: string*/\n  ) {\n    (0, _classCallCheck2.default)(this, ParseSchema);\n    (0, _defineProperty2.default)(this, \"className\", void 0);\n    (0, _defineProperty2.default)(this, \"_fields\", void 0);\n    (0, _defineProperty2.default)(this, \"_indexes\", void 0);\n    (0, _defineProperty2.default)(this, \"_clp\", void 0);\n\n    if (typeof className === 'string') {\n      if (className === 'User' && _CoreManager.default.get('PERFORM_USER_REWRITE')) {\n        this.className = '_User';\n      } else {\n        this.className = className;\n      }\n    }\n\n    this._fields = {};\n    this._indexes = {};\n  }\n  /**\n   * Static method to get all schemas\n   *\n   * @returns {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n\n\n  (0, _createClass2.default)(ParseSchema, [{\n    key: \"get\",\n    value:\n    /**\n     * Get the Schema from Parse\n     *\n     * @returns {Promise} A promise that is resolved with the result when\n     * the query completes.\n     */\n    function () {\n      this.assertClassName();\n\n      var controller = _CoreManager.default.getSchemaController();\n\n      return controller.get(this.className).then(function (response) {\n        if (!response) {\n          throw new Error('Schema not found.');\n        }\n\n        return response;\n      });\n    }\n    /**\n     * Create a new Schema on Parse\n     *\n     * @returns {Promise} A promise that is resolved with the result when\n     * the query completes.\n     */\n\n  }, {\n    key: \"save\",\n    value: function () {\n      this.assertClassName();\n\n      var controller = _CoreManager.default.getSchemaController();\n\n      var params = {\n        className: this.className,\n        fields: this._fields,\n        indexes: this._indexes,\n        classLevelPermissions: this._clp\n      };\n      return controller.create(this.className, params);\n    }\n    /**\n     * Update a Schema on Parse\n     *\n     * @returns {Promise} A promise that is resolved with the result when\n     * the query completes.\n     */\n\n  }, {\n    key: \"update\",\n    value: function () {\n      this.assertClassName();\n\n      var controller = _CoreManager.default.getSchemaController();\n\n      var params = {\n        className: this.className,\n        fields: this._fields,\n        indexes: this._indexes,\n        classLevelPermissions: this._clp\n      };\n      this._fields = {};\n      this._indexes = {};\n      return controller.update(this.className, params);\n    }\n    /**\n     * Removing a Schema from Parse\n     * Can only be used on Schema without objects\n     *\n     * @returns {Promise} A promise that is resolved with the result when\n     * the query completes.\n     */\n\n  }, {\n    key: \"delete\",\n    value: function () {\n      this.assertClassName();\n\n      var controller = _CoreManager.default.getSchemaController();\n\n      return controller.delete(this.className);\n    }\n    /**\n     * Removes all objects from a Schema (class) in Parse.\n     * EXERCISE CAUTION, running this will delete all objects for this schema and cannot be reversed\n     *\n     * @returns {Promise} A promise that is resolved with the result when\n     * the query completes.\n     */\n\n  }, {\n    key: \"purge\",\n    value: function () {\n      this.assertClassName();\n\n      var controller = _CoreManager.default.getSchemaController();\n\n      return controller.purge(this.className);\n    }\n    /**\n     * Assert if ClassName has been filled\n     *\n     * @private\n     */\n\n  }, {\n    key: \"assertClassName\",\n    value: function () {\n      if (!this.className) {\n        throw new Error('You must set a Class Name before making any request.');\n      }\n    }\n    /**\n     * Sets Class Level Permissions when creating / updating a Schema.\n     * EXERCISE CAUTION, running this may override CLP for this schema and cannot be reversed\n     *\n     * @param {object | Parse.CLP} clp Class Level Permissions\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"setCLP\",\n    value: function (clp\n    /*: PermissionsMap | ParseCLP*/\n    ) {\n      if (clp instanceof _ParseCLP.default) {\n        this._clp = clp.toJSON();\n      } else {\n        this._clp = clp;\n      }\n\n      return this;\n    }\n    /**\n     * Adding a Field to Create / Update a Schema\n     *\n     * @param {string} name Name of the field that will be created on Parse\n     * @param {string} type Can be a (String|Number|Boolean|Date|Parse.File|Parse.GeoPoint|Array|Object|Pointer|Parse.Relation)\n     * @param {object} options\n     * Valid options are:<ul>\n     *   <li>required: If field is not set, save operation fails (Requires Parse Server 3.7.0+)\n     *   <li>defaultValue: If field is not set, a default value is selected (Requires Parse Server 3.7.0+)\n     *   <li>targetClass: Required if type is Pointer or Parse.Relation\n     * </ul>\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addField\",\n    value: function (name\n    /*: string*/\n    , type\n    /*: string*/\n    ) {\n      var options\n      /*: FieldOptions*/\n      = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      type = type || 'String';\n\n      if (!name) {\n        throw new Error('field name may not be null.');\n      }\n\n      if ((0, _indexOf.default)(FIELD_TYPES).call(FIELD_TYPES, type) === -1) {\n        throw new Error(\"\".concat(type, \" is not a valid type.\"));\n      }\n\n      if (type === 'Pointer') {\n        return this.addPointer(name, options.targetClass, options);\n      }\n\n      if (type === 'Relation') {\n        return this.addRelation(name, options.targetClass, options);\n      }\n\n      var fieldOptions = {\n        type: type\n      };\n\n      if (typeof options.required === 'boolean') {\n        fieldOptions.required = options.required;\n      }\n\n      if (options.defaultValue !== undefined) {\n        fieldOptions.defaultValue = options.defaultValue;\n      }\n\n      if (type === 'Date') {\n        if (options && options.defaultValue) {\n          fieldOptions.defaultValue = {\n            __type: 'Date',\n            iso: new Date(options.defaultValue)\n          };\n        }\n      }\n\n      this._fields[name] = fieldOptions;\n      return this;\n    }\n    /**\n     * Adding an Index to Create / Update a Schema\n     *\n     * @param {string} name Name of the index\n     * @param {object} index { field: value }\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n     *\n     * <pre>\n     * schema.addIndex('index_name', { 'field': 1 });\n     * </pre>\n     */\n\n  }, {\n    key: \"addIndex\",\n    value: function (name\n    /*: string*/\n    , index\n    /*: any*/\n    ) {\n      if (!name) {\n        throw new Error('index name may not be null.');\n      }\n\n      if (!index) {\n        throw new Error('index may not be null.');\n      }\n\n      this._indexes[name] = index;\n      return this;\n    }\n    /**\n     * Adding String Field\n     *\n     * @param {string} name Name of the field that will be created on Parse\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addString\",\n    value: function (name\n    /*: string*/\n    , options\n    /*: FieldOptions*/\n    ) {\n      return this.addField(name, 'String', options);\n    }\n    /**\n     * Adding Number Field\n     *\n     * @param {string} name Name of the field that will be created on Parse\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addNumber\",\n    value: function (name\n    /*: string*/\n    , options\n    /*: FieldOptions*/\n    ) {\n      return this.addField(name, 'Number', options);\n    }\n    /**\n     * Adding Boolean Field\n     *\n     * @param {string} name Name of the field that will be created on Parse\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addBoolean\",\n    value: function (name\n    /*: string*/\n    , options\n    /*: FieldOptions*/\n    ) {\n      return this.addField(name, 'Boolean', options);\n    }\n    /**\n     * Adding Date Field\n     *\n     * @param {string} name Name of the field that will be created on Parse\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addDate\",\n    value: function (name\n    /*: string*/\n    , options\n    /*: FieldOptions*/\n    ) {\n      return this.addField(name, 'Date', options);\n    }\n    /**\n     * Adding File Field\n     *\n     * @param {string} name Name of the field that will be created on Parse\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addFile\",\n    value: function (name\n    /*: string*/\n    , options\n    /*: FieldOptions*/\n    ) {\n      return this.addField(name, 'File', options);\n    }\n    /**\n     * Adding GeoPoint Field\n     *\n     * @param {string} name Name of the field that will be created on Parse\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addGeoPoint\",\n    value: function (name\n    /*: string*/\n    , options\n    /*: FieldOptions*/\n    ) {\n      return this.addField(name, 'GeoPoint', options);\n    }\n    /**\n     * Adding Polygon Field\n     *\n     * @param {string} name Name of the field that will be created on Parse\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addPolygon\",\n    value: function (name\n    /*: string*/\n    , options\n    /*: FieldOptions*/\n    ) {\n      return this.addField(name, 'Polygon', options);\n    }\n    /**\n     * Adding Array Field\n     *\n     * @param {string} name Name of the field that will be created on Parse\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addArray\",\n    value: function (name\n    /*: string*/\n    , options\n    /*: FieldOptions*/\n    ) {\n      return this.addField(name, 'Array', options);\n    }\n    /**\n     * Adding Object Field\n     *\n     * @param {string} name Name of the field that will be created on Parse\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addObject\",\n    value: function (name\n    /*: string*/\n    , options\n    /*: FieldOptions*/\n    ) {\n      return this.addField(name, 'Object', options);\n    }\n    /**\n     * Adding Pointer Field\n     *\n     * @param {string} name Name of the field that will be created on Parse\n     * @param {string} targetClass Name of the target Pointer Class\n     * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addPointer\",\n    value: function (name\n    /*: string*/\n    , targetClass\n    /*: string*/\n    ) {\n      var options\n      /*: FieldOptions*/\n      = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (!name) {\n        throw new Error('field name may not be null.');\n      }\n\n      if (!targetClass) {\n        throw new Error('You need to set the targetClass of the Pointer.');\n      }\n\n      var fieldOptions = {\n        type: 'Pointer',\n        targetClass: targetClass\n      };\n\n      if (typeof options.required === 'boolean') {\n        fieldOptions.required = options.required;\n      }\n\n      if (options.defaultValue !== undefined) {\n        fieldOptions.defaultValue = options.defaultValue;\n\n        if (options.defaultValue instanceof _ParseObject.default) {\n          fieldOptions.defaultValue = options.defaultValue.toPointer();\n        }\n      }\n\n      this._fields[name] = fieldOptions;\n      return this;\n    }\n    /**\n     * Adding Relation Field\n     *\n     * @param {string} name Name of the field that will be created on Parse\n     * @param {string} targetClass Name of the target Pointer Class\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addRelation\",\n    value: function (name\n    /*: string*/\n    , targetClass\n    /*: string*/\n    ) {\n      if (!name) {\n        throw new Error('field name may not be null.');\n      }\n\n      if (!targetClass) {\n        throw new Error('You need to set the targetClass of the Relation.');\n      }\n\n      this._fields[name] = {\n        type: 'Relation',\n        targetClass: targetClass\n      };\n      return this;\n    }\n    /**\n     * Deleting a Field to Update on a Schema\n     *\n     * @param {string} name Name of the field\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"deleteField\",\n    value: function (name\n    /*: string*/\n    ) {\n      this._fields[name] = {\n        __op: 'Delete'\n      };\n      return this;\n    }\n    /**\n     * Deleting an Index to Update on a Schema\n     *\n     * @param {string} name Name of the field\n     * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"deleteIndex\",\n    value: function (name\n    /*: string*/\n    ) {\n      this._indexes[name] = {\n        __op: 'Delete'\n      };\n      return this;\n    }\n  }], [{\n    key: \"all\",\n    value: function () {\n      var controller = _CoreManager.default.getSchemaController();\n\n      return controller.get('').then(function (response) {\n        if (response.results.length === 0) {\n          throw new Error('Schema not found.');\n        }\n\n        return response.results;\n      });\n    }\n  }]);\n  return ParseSchema;\n}();\n\nvar DefaultController = {\n  send: function (className\n  /*: string*/\n  , method\n  /*: string*/\n  )\n  /*: Promise*/\n  {\n    var params\n    /*: any*/\n    = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    var RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request(method, \"schemas/\".concat(className), params, {\n      useMasterKey: true\n    });\n  },\n  get: function (className\n  /*: string*/\n  )\n  /*: Promise*/\n  {\n    return this.send(className, 'GET');\n  },\n  create: function (className\n  /*: string*/\n  , params\n  /*: any*/\n  )\n  /*: Promise*/\n  {\n    return this.send(className, 'POST', params);\n  },\n  update: function (className\n  /*: string*/\n  , params\n  /*: any*/\n  )\n  /*: Promise*/\n  {\n    return this.send(className, 'PUT', params);\n  },\n  delete: function (className\n  /*: string*/\n  )\n  /*: Promise*/\n  {\n    return this.send(className, 'DELETE');\n  },\n  purge: function (className\n  /*: string*/\n  )\n  /*: Promise*/\n  {\n    var RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('DELETE', \"purge/\".concat(className), {}, {\n      useMasterKey: true\n    });\n  }\n};\n\n_CoreManager.default.setSchemaController(DefaultController);\n\nvar _default = ParseSchema;\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}