{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _Object$defineProperties = require(\"@babel/runtime-corejs3/core-js-stable/object/define-properties\");\nvar _Object$getOwnPropertyDescriptors = require(\"@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors\");\nvar _forEachInstanceProperty = require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\");\nvar _Object$getOwnPropertyDescriptor = require(\"@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor\");\nvar _filterInstanceProperty = require(\"@babel/runtime-corejs3/core-js-stable/instance/filter\");\nvar _Object$getOwnPropertySymbols = require(\"@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols\");\nvar _Object$keys2 = require(\"@babel/runtime-corejs3/core-js-stable/object/keys\");\nvar _Array$isArray2 = require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\");\nvar _getIteratorMethod = require(\"@babel/runtime-corejs3/core-js/get-iterator-method\");\nvar _Symbol = require(\"@babel/runtime-corejs3/core-js-stable/symbol\");\nvar _Array$from = require(\"@babel/runtime-corejs3/core-js-stable/array/from\");\nvar _sliceInstanceProperty2 = require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/keys\"));\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\nvar _assign = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/assign\"));\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/slicedToArray\"));\nvar _entries = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/entries\"));\nvar _every = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/every\"));\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/typeof\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/createClass\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/map\"));\nvar _ParseRole = _interopRequireDefault(require(\"./ParseRole\"));\nvar _ParseUser = _interopRequireDefault(require(\"./ParseUser\"));\nfunction ownKeys(object, enumerableOnly) {\n  var keys = _Object$keys2(object);\n  if (_Object$getOwnPropertySymbols) {\n    var symbols = _Object$getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) {\n      return _Object$getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var _context3, _context4;\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? _forEachInstanceProperty(_context3 = ownKeys(Object(source), !0)).call(_context3, function (key) {\n      (0, _defineProperty2.default)(target, key, source[key]);\n    }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty(_context4 = ownKeys(Object(source))).call(_context4, function (key) {\n      _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof _Symbol !== \"undefined\" && _getIteratorMethod(o) || o[\"@@iterator\"];\n  if (!it) {\n    if (_Array$isArray2(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function () {};\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function () {\n      it = it.call(o);\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  var _context2;\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = _sliceInstanceProperty2(_context2 = Object.prototype.toString.call(o)).call(_context2, 8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return _Array$from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nvar PUBLIC_KEY = '*';\nvar VALID_PERMISSIONS\n/*: Map<string, UsersMap>*/ = new _map.default();\nVALID_PERMISSIONS.set('get', {});\nVALID_PERMISSIONS.set('find', {});\nVALID_PERMISSIONS.set('count', {});\nVALID_PERMISSIONS.set('create', {});\nVALID_PERMISSIONS.set('update', {});\nVALID_PERMISSIONS.set('delete', {});\nVALID_PERMISSIONS.set('addField', {});\nvar VALID_PERMISSIONS_EXTENDED\n/*: Map<string, UsersMap>*/ = new _map.default();\nVALID_PERMISSIONS_EXTENDED.set('protectedFields', {});\n/**\n * Creates a new CLP.\n * If no argument is given, the CLP has no permissions for anyone.\n * If the argument is a Parse.User or Parse.Role, the CLP will have read and write\n *   permission for only that user or role.\n * If the argument is any other JSON object, that object will be interpretted\n *   as a serialized CLP created with toJSON().\n *\n * <p>A CLP, or Class Level Permissions can be added to any\n * <code>Parse.Schema</code> to restrict access to only a subset of users\n * of your application.</p>\n *\n * <p>\n * For get/count/find/create/update/delete/addField using the following functions:\n *\n * Entity is type Parse.User or Parse.Role or string\n * Role is type Parse.Role or Name of Parse.Role\n *\n * getGetRequiresAuthentication()\n * setGetRequiresAuthentication(allowed: boolean)\n * getGetPointerFields()\n * setGetPointerFields(pointerFields: string[])\n * getGetAccess(entity: Entity)\n * setGetAccess(entity: Entity, allowed: boolean)\n * getPublicGetAccess()\n * setPublicGetAccess(allowed: boolean)\n * getRoleGetAccess(role: Role)\n * setRoleGetAccess(role: Role, allowed: boolean)\n * getFindRequiresAuthentication()\n * setFindRequiresAuthentication(allowed: boolean)\n * getFindPointerFields()\n * setFindPointerFields(pointerFields: string[])\n * getFindAccess(entity: Entity)\n * setFindAccess(entity: Entity, allowed: boolean)\n * getPublicFindAccess()\n * setPublicFindAccess(allowed: boolean)\n * getRoleFindAccess(role: Role)\n * setRoleFindAccess(role: Role, allowed: boolean)\n * getCountRequiresAuthentication()\n * setCountRequiresAuthentication(allowed: boolean)\n * getCountPointerFields()\n * setCountPointerFields(pointerFields: string[])\n * getCountAccess(entity: Entity)\n * setCountAccess(entity: Entity, allowed: boolean)\n * getPublicCountAccess()\n * setPublicCountAccess(allowed: boolean)\n * getRoleCountAccess(role: Role)\n * setRoleCountAccess(role: Role, allowed: boolean)\n * getCreateRequiresAuthentication()\n * setCreateRequiresAuthentication(allowed: boolean)\n * getCreatePointerFields()\n * setCreatePointerFields(pointerFields: string[])\n * getCreateAccess(entity: Entity)\n * setCreateAccess(entity: Entity, allowed: boolean)\n * getPublicCreateAccess()\n * setPublicCreateAccess(allowed: Boolean)\n * getRoleCreateAccess(role: Role)\n * setRoleCreateAccess(role: Role, allowed: boolean)\n * getUpdateRequiresAuthentication()\n * setUpdateRequiresAuthentication(allowed: boolean)\n * getUpdatePointerFields()\n * setUpdatePointerFields(pointerFields: string[])\n * getUpdateAccess(entity: Entity)\n * setUpdateAccess(entity: Entity, allowed: boolean)\n * getPublicUpdateAccess()\n * setPublicUpdateAccess(allowed: boolean)\n * getRoleUpdateAccess(role: Role)\n * setRoleUpdateAccess(role: Role, allowed: boolean)\n * getDeleteRequiresAuthentication()\n * setDeleteRequiresAuthentication(allowed: boolean)\n * getDeletePointerFields()\n * setDeletePointerFields(pointerFields: string[])\n * getDeleteAccess(entity: Entity)\n * setDeleteAccess(entity: Entity, allowed: boolean)\n * getPublicDeleteAccess()\n * setPublicDeleteAccess(allowed: boolean)\n * getRoleDeleteAccess(role: Role)\n * setRoleDeleteAccess(role: Role, allowed: boolean)\n * getAddFieldRequiresAuthentication()\n * setAddFieldRequiresAuthentication(allowed: boolean)\n * getAddFieldPointerFields()\n * setAddFieldPointerFields(pointerFields: string[])\n * getAddFieldAccess(entity: Entity)\n * setAddFieldAccess(entity: Entity, allowed: boolean)\n * getPublicAddFieldAccess()\n * setPublicAddFieldAccess(allowed: boolean)\n * getRoleAddFieldAccess(role: Role)\n * setRoleAddFieldAccess(role: Role, allowed: boolean)\n * </p>\n *\n * @alias Parse.CLP\n */\n\nvar ParseCLP = /*#__PURE__*/function () {\n  /**\n   * @param {(Parse.User | Parse.Role | object)} userId The user to initialize the CLP for\n   */\n  function ParseCLP(userId\n  /*: ParseUser | ParseRole | PermissionsMap*/) {\n    var _this = this;\n    (0, _classCallCheck2.default)(this, ParseCLP);\n    (0, _defineProperty2.default)(this, \"permissionsMap\", void 0);\n    this.permissionsMap = {}; // Initialize permissions Map with default permissions\n\n    var _iterator = _createForOfIteratorHelper((0, _entries.default)(VALID_PERMISSIONS).call(VALID_PERMISSIONS)),\n      _step;\n    try {\n      var _loop = function _loop() {\n        var _step$value = (0, _slicedToArray2.default)(_step.value, 2),\n          operation = _step$value[0],\n          group = _step$value[1];\n        _this.permissionsMap[operation] = (0, _assign.default)({}, group);\n        var action = operation.charAt(0).toUpperCase() + (0, _slice.default)(operation).call(operation, 1);\n        _this[\"get\".concat(action, \"RequiresAuthentication\")] = function () {\n          return this._getAccess(operation, 'requiresAuthentication');\n        };\n        _this[\"set\".concat(action, \"RequiresAuthentication\")] = function (allowed) {\n          this._setAccess(operation, 'requiresAuthentication', allowed);\n        };\n        _this[\"get\".concat(action, \"PointerFields\")] = function () {\n          return this._getAccess(operation, 'pointerFields', false);\n        };\n        _this[\"set\".concat(action, \"PointerFields\")] = function (pointerFields) {\n          this._setArrayAccess(operation, 'pointerFields', pointerFields);\n        };\n        _this[\"get\".concat(action, \"Access\")] = function (entity) {\n          return this._getAccess(operation, entity);\n        };\n        _this[\"set\".concat(action, \"Access\")] = function (entity, allowed) {\n          this._setAccess(operation, entity, allowed);\n        };\n        _this[\"getPublic\".concat(action, \"Access\")] = function () {\n          return this[\"get\".concat(action, \"Access\")](PUBLIC_KEY);\n        };\n        _this[\"setPublic\".concat(action, \"Access\")] = function (allowed) {\n          this[\"set\".concat(action, \"Access\")](PUBLIC_KEY, allowed);\n        };\n        _this[\"getRole\".concat(action, \"Access\")] = function (role) {\n          return this[\"get\".concat(action, \"Access\")](this._getRoleName(role));\n        };\n        _this[\"setRole\".concat(action, \"Access\")] = function (role, allowed) {\n          this[\"set\".concat(action, \"Access\")](this._getRoleName(role), allowed);\n        };\n      };\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        _loop();\n      } // Initialize permissions Map with default extended permissions\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    var _iterator2 = _createForOfIteratorHelper((0, _entries.default)(VALID_PERMISSIONS_EXTENDED).call(VALID_PERMISSIONS_EXTENDED)),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _step2$value = (0, _slicedToArray2.default)(_step2.value, 2),\n          operation = _step2$value[0],\n          group = _step2$value[1];\n        this.permissionsMap[operation] = (0, _assign.default)({}, group);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    if (userId && (0, _typeof2.default)(userId) === 'object') {\n      if (userId instanceof _ParseUser.default) {\n        this.setReadAccess(userId, true);\n        this.setWriteAccess(userId, true);\n      } else if (userId instanceof _ParseRole.default) {\n        this.setRoleReadAccess(userId, true);\n        this.setRoleWriteAccess(userId, true);\n      } else {\n        for (var _permission in userId) {\n          var _context;\n          var users = userId[_permission];\n          var isValidPermission = !!VALID_PERMISSIONS.get(_permission);\n          var isValidPermissionExtended = !!VALID_PERMISSIONS_EXTENDED.get(_permission);\n          var isValidGroupPermission = (0, _includes.default)(_context = ['readUserFields', 'writeUserFields']).call(_context, _permission);\n          if (typeof _permission !== 'string' || !(isValidPermission || isValidPermissionExtended || isValidGroupPermission)) {\n            throw new TypeError('Tried to create an CLP with an invalid permission type.');\n          }\n          if (isValidGroupPermission) {\n            if ((0, _every.default)(users).call(users, function (pointer) {\n              return typeof pointer === 'string';\n            })) {\n              this.permissionsMap[_permission] = users;\n              continue;\n            } else {\n              throw new TypeError('Tried to create an CLP with an invalid permission value.');\n            }\n          }\n          for (var user in users) {\n            var allowed = users[user];\n            if (typeof allowed !== 'boolean' && !isValidPermissionExtended && user !== 'pointerFields') {\n              throw new TypeError('Tried to create an CLP with an invalid permission value.');\n            }\n            this.permissionsMap[_permission][user] = allowed;\n          }\n        }\n      }\n    } else if (typeof userId === 'function') {\n      throw new TypeError('ParseCLP constructed with a function. Did you forget ()?');\n    }\n  }\n  /**\n   * Returns a JSON-encoded version of the CLP.\n   *\n   * @returns {object}\n   */\n\n  (0, _createClass2.default)(ParseCLP, [{\n    key: \"toJSON\",\n    value: function toJSON() /*: PermissionsMap*/\n    {\n      return _objectSpread({}, this.permissionsMap);\n    }\n    /**\n     * Returns whether this CLP is equal to another object\n     *\n     * @param other The other object to compare to\n     * @returns {boolean}\n     */\n  }, {\n    key: \"equals\",\n    value: function equals(other\n    /*: ParseCLP*/) /*: boolean*/\n    {\n      if (!(other instanceof ParseCLP)) {\n        return false;\n      }\n      var permissions = (0, _keys.default)(this.permissionsMap);\n      var otherPermissions = (0, _keys.default)(other.permissionsMap);\n      if (permissions.length !== otherPermissions.length) {\n        return false;\n      }\n      for (var _permission2 in this.permissionsMap) {\n        if (!other.permissionsMap[_permission2]) {\n          return false;\n        }\n        var users = (0, _keys.default)(this.permissionsMap[_permission2]);\n        var otherUsers = (0, _keys.default)(other.permissionsMap[_permission2]);\n        if (users.length !== otherUsers.length) {\n          return false;\n        }\n        for (var user in this.permissionsMap[_permission2]) {\n          if (!other.permissionsMap[_permission2][user]) {\n            return false;\n          }\n          if (this.permissionsMap[_permission2][user] !== other.permissionsMap[_permission2][user]) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"_getRoleName\",\n    value: function _getRoleName(role\n    /*: ParseRole | string*/) /*: string*/\n    {\n      var name = role;\n      if (role instanceof _ParseRole.default) {\n        // Normalize to the String name\n        name = role.getName();\n      }\n      if (typeof name !== 'string') {\n        throw new TypeError('role must be a Parse.Role or a String');\n      }\n      return \"role:\".concat(name);\n    }\n  }, {\n    key: \"_parseEntity\",\n    value: function _parseEntity(entity\n    /*: Entity*/) {\n      var userId = entity;\n      if (userId instanceof _ParseUser.default) {\n        userId = userId.id;\n        if (!userId) {\n          throw new Error('Cannot get access for a Parse.User without an id.');\n        }\n      } else if (userId instanceof _ParseRole.default) {\n        userId = this._getRoleName(userId);\n      }\n      if (typeof userId !== 'string') {\n        throw new TypeError('userId must be a string.');\n      }\n      return userId;\n    }\n  }, {\n    key: \"_setAccess\",\n    value: function _setAccess(permission\n    /*: string*/, userId\n    /*: Entity*/, allowed\n    /*: boolean*/) {\n      userId = this._parseEntity(userId);\n      if (typeof allowed !== 'boolean') {\n        throw new TypeError('allowed must be either true or false.');\n      }\n      var permissions = this.permissionsMap[permission][userId];\n      if (!permissions) {\n        if (!allowed) {\n          // The user already doesn't have this permission, so no action is needed\n          return;\n        } else {\n          this.permissionsMap[permission][userId] = {};\n        }\n      }\n      if (allowed) {\n        this.permissionsMap[permission][userId] = true;\n      } else {\n        delete this.permissionsMap[permission][userId];\n      }\n    }\n  }, {\n    key: \"_getAccess\",\n    value: function _getAccess(permission\n    /*: string*/, userId\n    /*: Entity*/) /*: boolean | string[]*/\n    {\n      var returnBoolean = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      userId = this._parseEntity(userId);\n      var permissions = this.permissionsMap[permission][userId];\n      if (returnBoolean) {\n        if (!permissions) {\n          return false;\n        }\n        return !!this.permissionsMap[permission][userId];\n      }\n      return permissions;\n    }\n  }, {\n    key: \"_setArrayAccess\",\n    value: function _setArrayAccess(permission\n    /*: string*/, userId\n    /*: Entity*/, fields\n    /*: string*/) {\n      userId = this._parseEntity(userId);\n      var permissions = this.permissionsMap[permission][userId];\n      if (!permissions) {\n        this.permissionsMap[permission][userId] = [];\n      }\n      if (!fields || (0, _isArray.default)(fields) && fields.length === 0) {\n        delete this.permissionsMap[permission][userId];\n      } else if ((0, _isArray.default)(fields) && (0, _every.default)(fields).call(fields, function (field) {\n        return typeof field === 'string';\n      })) {\n        this.permissionsMap[permission][userId] = fields;\n      } else {\n        throw new TypeError('fields must be an array of strings or undefined.');\n      }\n    }\n  }, {\n    key: \"_setGroupPointerPermission\",\n    value: function _setGroupPointerPermission(operation\n    /*: string*/, pointerFields\n    /*: string[]*/) {\n      var fields = this.permissionsMap[operation];\n      if (!fields) {\n        this.permissionsMap[operation] = [];\n      }\n      if (!pointerFields || (0, _isArray.default)(pointerFields) && pointerFields.length === 0) {\n        delete this.permissionsMap[operation];\n      } else if ((0, _isArray.default)(pointerFields) && (0, _every.default)(pointerFields).call(pointerFields, function (field) {\n        return typeof field === 'string';\n      })) {\n        this.permissionsMap[operation] = pointerFields;\n      } else {\n        throw new TypeError(\"\".concat(operation, \".pointerFields must be an array of strings or undefined.\"));\n      }\n    }\n  }, {\n    key: \"_getGroupPointerPermissions\",\n    value: function _getGroupPointerPermissions(operation\n    /*: string*/) /*: string[]*/\n    {\n      return this.permissionsMap[operation];\n    }\n    /**\n     * Sets user pointer fields to allow permission for get/count/find operations.\n     *\n     * @param {string[]} pointerFields User pointer fields\n     */\n  }, {\n    key: \"setReadUserFields\",\n    value: function setReadUserFields(pointerFields\n    /*: string[]*/) {\n      this._setGroupPointerPermission('readUserFields', pointerFields);\n    }\n    /**\n     * @returns {string[]} User pointer fields\n     */\n  }, {\n    key: \"getReadUserFields\",\n    value: function getReadUserFields() /*: string[]*/\n    {\n      return this._getGroupPointerPermissions('readUserFields');\n    }\n    /**\n     * Sets user pointer fields to allow permission for create/delete/update/addField operations\n     *\n     * @param {string[]} pointerFields User pointer fields\n     */\n  }, {\n    key: \"setWriteUserFields\",\n    value: function setWriteUserFields(pointerFields\n    /*: string[]*/) {\n      this._setGroupPointerPermission('writeUserFields', pointerFields);\n    }\n    /**\n     * @returns {string[]} User pointer fields\n     */\n  }, {\n    key: \"getWriteUserFields\",\n    value: function getWriteUserFields() /*: string[]*/\n    {\n      return this._getGroupPointerPermissions('writeUserFields');\n    }\n    /**\n     * Sets whether the given user is allowed to retrieve fields from this class.\n     *\n     * @param userId An instance of Parse.User or its objectId.\n     * @param {string[]} fields fields to be protected\n     */\n  }, {\n    key: \"setProtectedFields\",\n    value: function setProtectedFields(userId\n    /*: Entity*/, fields\n    /*: string[]*/) {\n      this._setArrayAccess('protectedFields', userId, fields);\n    }\n    /**\n     * Returns array of fields are accessable to this user.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n     * @returns {string[]}\n     */\n  }, {\n    key: \"getProtectedFields\",\n    value: function getProtectedFields(userId\n    /*: Entity*/) /*: string[]*/\n    {\n      return this._getAccess('protectedFields', userId, false);\n    }\n    /**\n     * Sets whether the given user is allowed to read from this class.\n     *\n     * @param userId An instance of Parse.User or its objectId.\n     * @param {boolean} allowed whether that user should have read access.\n     */\n  }, {\n    key: \"setReadAccess\",\n    value: function setReadAccess(userId\n    /*: Entity*/, allowed\n    /*: boolean*/) {\n      this._setAccess('find', userId, allowed);\n      this._setAccess('get', userId, allowed);\n      this._setAccess('count', userId, allowed);\n    }\n    /**\n     * Get whether the given user id is *explicitly* allowed to read from this class.\n     * Even if this returns false, the user may still be able to access it if\n     * getPublicReadAccess returns true or a role that the user belongs to has\n     * write access.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"getReadAccess\",\n    value: function getReadAccess(userId\n    /*: Entity*/) /*: boolean*/\n    {\n      return this._getAccess('find', userId) && this._getAccess('get', userId) && this._getAccess('count', userId);\n    }\n    /**\n     * Sets whether the given user id is allowed to write to this class.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role..\n     * @param {boolean} allowed Whether that user should have write access.\n     */\n  }, {\n    key: \"setWriteAccess\",\n    value: function setWriteAccess(userId\n    /*: Entity*/, allowed\n    /*: boolean*/) {\n      this._setAccess('create', userId, allowed);\n      this._setAccess('update', userId, allowed);\n      this._setAccess('delete', userId, allowed);\n      this._setAccess('addField', userId, allowed);\n    }\n    /**\n     * Gets whether the given user id is *explicitly* allowed to write to this class.\n     * Even if this returns false, the user may still be able to write it if\n     * getPublicWriteAccess returns true or a role that the user belongs to has\n     * write access.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"getWriteAccess\",\n    value: function getWriteAccess(userId\n    /*: Entity*/) /*: boolean*/\n    {\n      return this._getAccess('create', userId) && this._getAccess('update', userId) && this._getAccess('delete', userId) && this._getAccess('addField', userId);\n    }\n    /**\n     * Sets whether the public is allowed to read from this class.\n     *\n     * @param {boolean} allowed\n     */\n  }, {\n    key: \"setPublicReadAccess\",\n    value: function setPublicReadAccess(allowed\n    /*: boolean*/) {\n      this.setReadAccess(PUBLIC_KEY, allowed);\n    }\n    /**\n     * Gets whether the public is allowed to read from this class.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"getPublicReadAccess\",\n    value: function getPublicReadAccess() /*: boolean*/\n    {\n      return this.getReadAccess(PUBLIC_KEY);\n    }\n    /**\n     * Sets whether the public is allowed to write to this class.\n     *\n     * @param {boolean} allowed\n     */\n  }, {\n    key: \"setPublicWriteAccess\",\n    value: function setPublicWriteAccess(allowed\n    /*: boolean*/) {\n      this.setWriteAccess(PUBLIC_KEY, allowed);\n    }\n    /**\n     * Gets whether the public is allowed to write to this class.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"getPublicWriteAccess\",\n    value: function getPublicWriteAccess() /*: boolean*/\n    {\n      return this.getWriteAccess(PUBLIC_KEY);\n    }\n    /**\n     * Sets whether the public is allowed to protect fields in this class.\n     *\n     * @param {string[]} fields\n     */\n  }, {\n    key: \"setPublicProtectedFields\",\n    value: function setPublicProtectedFields(fields\n    /*: string[]*/) {\n      this.setProtectedFields(PUBLIC_KEY, fields);\n    }\n    /**\n     * Gets whether the public is allowed to read fields from this class.\n     *\n     * @returns {string[]}\n     */\n  }, {\n    key: \"getPublicProtectedFields\",\n    value: function getPublicProtectedFields() /*: string[]*/\n    {\n      return this.getProtectedFields(PUBLIC_KEY);\n    }\n    /**\n     * Gets whether users belonging to the given role are allowed\n     * to read from this class. Even if this returns false, the role may\n     * still be able to write it if a parent role has read access.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @returns {boolean} true if the role has read access. false otherwise.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n  }, {\n    key: \"getRoleReadAccess\",\n    value: function getRoleReadAccess(role\n    /*: ParseRole | string*/) /*: boolean*/\n    {\n      return this.getReadAccess(this._getRoleName(role));\n    }\n    /**\n     * Gets whether users belonging to the given role are allowed\n     * to write to this user. Even if this returns false, the role may\n     * still be able to write it if a parent role has write access.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @returns {boolean} true if the role has write access. false otherwise.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n  }, {\n    key: \"getRoleWriteAccess\",\n    value: function getRoleWriteAccess(role\n    /*: ParseRole | string*/) /*: boolean*/\n    {\n      return this.getWriteAccess(this._getRoleName(role));\n    }\n    /**\n     * Sets whether users belonging to the given role are allowed\n     * to read from this class.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @param {boolean} allowed Whether the given role can read this object.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n  }, {\n    key: \"setRoleReadAccess\",\n    value: function setRoleReadAccess(role\n    /*: ParseRole | string*/, allowed\n    /*: boolean*/) {\n      this.setReadAccess(this._getRoleName(role), allowed);\n    }\n    /**\n     * Sets whether users belonging to the given role are allowed\n     * to write to this class.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @param {boolean} allowed Whether the given role can write this object.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n  }, {\n    key: \"setRoleWriteAccess\",\n    value: function setRoleWriteAccess(role\n    /*: ParseRole | string*/, allowed\n    /*: boolean*/) {\n      this.setWriteAccess(this._getRoleName(role), allowed);\n    }\n    /**\n     * Gets whether users belonging to the given role are allowed\n     * to count to this user. Even if this returns false, the role may\n     * still be able to count it if a parent role has count access.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @returns {string[]}\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n  }, {\n    key: \"getRoleProtectedFields\",\n    value: function getRoleProtectedFields(role\n    /*: ParseRole | string*/) /*: string[]*/\n    {\n      return this.getProtectedFields(this._getRoleName(role));\n    }\n    /**\n     * Sets whether users belonging to the given role are allowed\n     * to set access field in this class.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @param {string[]} fields Fields to be protected by Role.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n  }, {\n    key: \"setRoleProtectedFields\",\n    value: function setRoleProtectedFields(role\n    /*: ParseRole | string*/, fields\n    /*: string[]*/) {\n      this.setProtectedFields(this._getRoleName(role), fields);\n    }\n  }]);\n  return ParseCLP;\n}();\nvar _default = ParseCLP;\nexports.default = _default;","map":{"version":3,"names":["_interopRequireDefault","require","_Object$defineProperty","_Object$defineProperties","_Object$getOwnPropertyDescriptors","_forEachInstanceProperty","_Object$getOwnPropertyDescriptor","_filterInstanceProperty","_Object$getOwnPropertySymbols","_Object$keys2","_Array$isArray2","_getIteratorMethod","_Symbol","_Array$from","_sliceInstanceProperty2","exports","value","default","_isArray","_keys","_slice","_assign","_slicedToArray2","_entries","_every","_includes","_typeof2","_classCallCheck2","_createClass2","_defineProperty2","_map","_ParseRole","_ParseUser","ownKeys","object","enumerableOnly","keys","symbols","call","sym","enumerable","push","apply","_objectSpread","target","i","arguments","length","_context3","_context4","source","Object","key","_createForOfIteratorHelper","o","allowArrayLike","it","_unsupportedIterableToArray","F","s","n","done","e","_e","f","TypeError","normalCompletion","didErr","err","step","next","_e2","return","minLen","_context2","_arrayLikeToArray","prototype","toString","constructor","name","test","arr","len","arr2","Array","PUBLIC_KEY","VALID_PERMISSIONS","set","VALID_PERMISSIONS_EXTENDED","ParseCLP","userId","_this","permissionsMap","_iterator","_step","_loop","_step$value","operation","group","action","charAt","toUpperCase","concat","_getAccess","allowed","_setAccess","pointerFields","_setArrayAccess","entity","role","_getRoleName","_iterator2","_step2","_step2$value","setReadAccess","setWriteAccess","setRoleReadAccess","setRoleWriteAccess","_permission","_context","users","isValidPermission","get","isValidPermissionExtended","isValidGroupPermission","pointer","user","toJSON","equals","other","permissions","otherPermissions","_permission2","otherUsers","getName","_parseEntity","id","Error","permission","returnBoolean","undefined","fields","field","_setGroupPointerPermission","_getGroupPointerPermissions","setReadUserFields","getReadUserFields","setWriteUserFields","getWriteUserFields","setProtectedFields","getProtectedFields","getReadAccess","getWriteAccess","setPublicReadAccess","getPublicReadAccess","setPublicWriteAccess","getPublicWriteAccess","setPublicProtectedFields","getPublicProtectedFields","getRoleReadAccess","getRoleWriteAccess","getRoleProtectedFields","setRoleProtectedFields","_default"],"sources":["/Users/nnwhalen/Desktop/NOTREDAME/web dev/node_modules/parse/lib/browser/ParseCLP.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\nvar _Object$defineProperties = require(\"@babel/runtime-corejs3/core-js-stable/object/define-properties\");\n\nvar _Object$getOwnPropertyDescriptors = require(\"@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors\");\n\nvar _forEachInstanceProperty = require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\");\n\nvar _Object$getOwnPropertyDescriptor = require(\"@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor\");\n\nvar _filterInstanceProperty = require(\"@babel/runtime-corejs3/core-js-stable/instance/filter\");\n\nvar _Object$getOwnPropertySymbols = require(\"@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols\");\n\nvar _Object$keys2 = require(\"@babel/runtime-corejs3/core-js-stable/object/keys\");\n\nvar _Array$isArray2 = require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\");\n\nvar _getIteratorMethod = require(\"@babel/runtime-corejs3/core-js/get-iterator-method\");\n\nvar _Symbol = require(\"@babel/runtime-corejs3/core-js-stable/symbol\");\n\nvar _Array$from = require(\"@babel/runtime-corejs3/core-js-stable/array/from\");\n\nvar _sliceInstanceProperty2 = require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\n\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/keys\"));\n\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\n\nvar _assign = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/assign\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/slicedToArray\"));\n\nvar _entries = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/entries\"));\n\nvar _every = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/every\"));\n\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/typeof\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\n\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/map\"));\n\nvar _ParseRole = _interopRequireDefault(require(\"./ParseRole\"));\n\nvar _ParseUser = _interopRequireDefault(require(\"./ParseUser\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = _Object$keys2(object);\n\n  if (_Object$getOwnPropertySymbols) {\n    var symbols = _Object$getOwnPropertySymbols(object);\n\n    enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) {\n      return _Object$getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var _context3, _context4;\n\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? _forEachInstanceProperty(_context3 = ownKeys(Object(source), !0)).call(_context3, function (key) {\n      (0, _defineProperty2.default)(target, key, source[key]);\n    }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty(_context4 = ownKeys(Object(source))).call(_context4, function (key) {\n      _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof _Symbol !== \"undefined\" && _getIteratorMethod(o) || o[\"@@iterator\"];\n\n  if (!it) {\n    if (_Array$isArray2(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = it.call(o);\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  var _context2;\n\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n\n  var n = _sliceInstanceProperty2(_context2 = Object.prototype.toString.call(o)).call(_context2, 8, -1);\n\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return _Array$from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar PUBLIC_KEY = '*';\nvar VALID_PERMISSIONS\n/*: Map<string, UsersMap>*/\n= new _map.default();\nVALID_PERMISSIONS.set('get', {});\nVALID_PERMISSIONS.set('find', {});\nVALID_PERMISSIONS.set('count', {});\nVALID_PERMISSIONS.set('create', {});\nVALID_PERMISSIONS.set('update', {});\nVALID_PERMISSIONS.set('delete', {});\nVALID_PERMISSIONS.set('addField', {});\nvar VALID_PERMISSIONS_EXTENDED\n/*: Map<string, UsersMap>*/\n= new _map.default();\nVALID_PERMISSIONS_EXTENDED.set('protectedFields', {});\n/**\n * Creates a new CLP.\n * If no argument is given, the CLP has no permissions for anyone.\n * If the argument is a Parse.User or Parse.Role, the CLP will have read and write\n *   permission for only that user or role.\n * If the argument is any other JSON object, that object will be interpretted\n *   as a serialized CLP created with toJSON().\n *\n * <p>A CLP, or Class Level Permissions can be added to any\n * <code>Parse.Schema</code> to restrict access to only a subset of users\n * of your application.</p>\n *\n * <p>\n * For get/count/find/create/update/delete/addField using the following functions:\n *\n * Entity is type Parse.User or Parse.Role or string\n * Role is type Parse.Role or Name of Parse.Role\n *\n * getGetRequiresAuthentication()\n * setGetRequiresAuthentication(allowed: boolean)\n * getGetPointerFields()\n * setGetPointerFields(pointerFields: string[])\n * getGetAccess(entity: Entity)\n * setGetAccess(entity: Entity, allowed: boolean)\n * getPublicGetAccess()\n * setPublicGetAccess(allowed: boolean)\n * getRoleGetAccess(role: Role)\n * setRoleGetAccess(role: Role, allowed: boolean)\n * getFindRequiresAuthentication()\n * setFindRequiresAuthentication(allowed: boolean)\n * getFindPointerFields()\n * setFindPointerFields(pointerFields: string[])\n * getFindAccess(entity: Entity)\n * setFindAccess(entity: Entity, allowed: boolean)\n * getPublicFindAccess()\n * setPublicFindAccess(allowed: boolean)\n * getRoleFindAccess(role: Role)\n * setRoleFindAccess(role: Role, allowed: boolean)\n * getCountRequiresAuthentication()\n * setCountRequiresAuthentication(allowed: boolean)\n * getCountPointerFields()\n * setCountPointerFields(pointerFields: string[])\n * getCountAccess(entity: Entity)\n * setCountAccess(entity: Entity, allowed: boolean)\n * getPublicCountAccess()\n * setPublicCountAccess(allowed: boolean)\n * getRoleCountAccess(role: Role)\n * setRoleCountAccess(role: Role, allowed: boolean)\n * getCreateRequiresAuthentication()\n * setCreateRequiresAuthentication(allowed: boolean)\n * getCreatePointerFields()\n * setCreatePointerFields(pointerFields: string[])\n * getCreateAccess(entity: Entity)\n * setCreateAccess(entity: Entity, allowed: boolean)\n * getPublicCreateAccess()\n * setPublicCreateAccess(allowed: Boolean)\n * getRoleCreateAccess(role: Role)\n * setRoleCreateAccess(role: Role, allowed: boolean)\n * getUpdateRequiresAuthentication()\n * setUpdateRequiresAuthentication(allowed: boolean)\n * getUpdatePointerFields()\n * setUpdatePointerFields(pointerFields: string[])\n * getUpdateAccess(entity: Entity)\n * setUpdateAccess(entity: Entity, allowed: boolean)\n * getPublicUpdateAccess()\n * setPublicUpdateAccess(allowed: boolean)\n * getRoleUpdateAccess(role: Role)\n * setRoleUpdateAccess(role: Role, allowed: boolean)\n * getDeleteRequiresAuthentication()\n * setDeleteRequiresAuthentication(allowed: boolean)\n * getDeletePointerFields()\n * setDeletePointerFields(pointerFields: string[])\n * getDeleteAccess(entity: Entity)\n * setDeleteAccess(entity: Entity, allowed: boolean)\n * getPublicDeleteAccess()\n * setPublicDeleteAccess(allowed: boolean)\n * getRoleDeleteAccess(role: Role)\n * setRoleDeleteAccess(role: Role, allowed: boolean)\n * getAddFieldRequiresAuthentication()\n * setAddFieldRequiresAuthentication(allowed: boolean)\n * getAddFieldPointerFields()\n * setAddFieldPointerFields(pointerFields: string[])\n * getAddFieldAccess(entity: Entity)\n * setAddFieldAccess(entity: Entity, allowed: boolean)\n * getPublicAddFieldAccess()\n * setPublicAddFieldAccess(allowed: boolean)\n * getRoleAddFieldAccess(role: Role)\n * setRoleAddFieldAccess(role: Role, allowed: boolean)\n * </p>\n *\n * @alias Parse.CLP\n */\n\nvar ParseCLP = /*#__PURE__*/function () {\n  /**\n   * @param {(Parse.User | Parse.Role | object)} userId The user to initialize the CLP for\n   */\n  function ParseCLP(userId\n  /*: ParseUser | ParseRole | PermissionsMap*/\n  ) {\n    var _this = this;\n\n    (0, _classCallCheck2.default)(this, ParseCLP);\n    (0, _defineProperty2.default)(this, \"permissionsMap\", void 0);\n    this.permissionsMap = {}; // Initialize permissions Map with default permissions\n\n    var _iterator = _createForOfIteratorHelper((0, _entries.default)(VALID_PERMISSIONS).call(VALID_PERMISSIONS)),\n        _step;\n\n    try {\n      var _loop = function _loop() {\n        var _step$value = (0, _slicedToArray2.default)(_step.value, 2),\n            operation = _step$value[0],\n            group = _step$value[1];\n\n        _this.permissionsMap[operation] = (0, _assign.default)({}, group);\n        var action = operation.charAt(0).toUpperCase() + (0, _slice.default)(operation).call(operation, 1);\n\n        _this[\"get\".concat(action, \"RequiresAuthentication\")] = function () {\n          return this._getAccess(operation, 'requiresAuthentication');\n        };\n\n        _this[\"set\".concat(action, \"RequiresAuthentication\")] = function (allowed) {\n          this._setAccess(operation, 'requiresAuthentication', allowed);\n        };\n\n        _this[\"get\".concat(action, \"PointerFields\")] = function () {\n          return this._getAccess(operation, 'pointerFields', false);\n        };\n\n        _this[\"set\".concat(action, \"PointerFields\")] = function (pointerFields) {\n          this._setArrayAccess(operation, 'pointerFields', pointerFields);\n        };\n\n        _this[\"get\".concat(action, \"Access\")] = function (entity) {\n          return this._getAccess(operation, entity);\n        };\n\n        _this[\"set\".concat(action, \"Access\")] = function (entity, allowed) {\n          this._setAccess(operation, entity, allowed);\n        };\n\n        _this[\"getPublic\".concat(action, \"Access\")] = function () {\n          return this[\"get\".concat(action, \"Access\")](PUBLIC_KEY);\n        };\n\n        _this[\"setPublic\".concat(action, \"Access\")] = function (allowed) {\n          this[\"set\".concat(action, \"Access\")](PUBLIC_KEY, allowed);\n        };\n\n        _this[\"getRole\".concat(action, \"Access\")] = function (role) {\n          return this[\"get\".concat(action, \"Access\")](this._getRoleName(role));\n        };\n\n        _this[\"setRole\".concat(action, \"Access\")] = function (role, allowed) {\n          this[\"set\".concat(action, \"Access\")](this._getRoleName(role), allowed);\n        };\n      };\n\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        _loop();\n      } // Initialize permissions Map with default extended permissions\n\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    var _iterator2 = _createForOfIteratorHelper((0, _entries.default)(VALID_PERMISSIONS_EXTENDED).call(VALID_PERMISSIONS_EXTENDED)),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _step2$value = (0, _slicedToArray2.default)(_step2.value, 2),\n            operation = _step2$value[0],\n            group = _step2$value[1];\n\n        this.permissionsMap[operation] = (0, _assign.default)({}, group);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    if (userId && (0, _typeof2.default)(userId) === 'object') {\n      if (userId instanceof _ParseUser.default) {\n        this.setReadAccess(userId, true);\n        this.setWriteAccess(userId, true);\n      } else if (userId instanceof _ParseRole.default) {\n        this.setRoleReadAccess(userId, true);\n        this.setRoleWriteAccess(userId, true);\n      } else {\n        for (var _permission in userId) {\n          var _context;\n\n          var users = userId[_permission];\n          var isValidPermission = !!VALID_PERMISSIONS.get(_permission);\n          var isValidPermissionExtended = !!VALID_PERMISSIONS_EXTENDED.get(_permission);\n          var isValidGroupPermission = (0, _includes.default)(_context = ['readUserFields', 'writeUserFields']).call(_context, _permission);\n\n          if (typeof _permission !== 'string' || !(isValidPermission || isValidPermissionExtended || isValidGroupPermission)) {\n            throw new TypeError('Tried to create an CLP with an invalid permission type.');\n          }\n\n          if (isValidGroupPermission) {\n            if ((0, _every.default)(users).call(users, function (pointer) {\n              return typeof pointer === 'string';\n            })) {\n              this.permissionsMap[_permission] = users;\n              continue;\n            } else {\n              throw new TypeError('Tried to create an CLP with an invalid permission value.');\n            }\n          }\n\n          for (var user in users) {\n            var allowed = users[user];\n\n            if (typeof allowed !== 'boolean' && !isValidPermissionExtended && user !== 'pointerFields') {\n              throw new TypeError('Tried to create an CLP with an invalid permission value.');\n            }\n\n            this.permissionsMap[_permission][user] = allowed;\n          }\n        }\n      }\n    } else if (typeof userId === 'function') {\n      throw new TypeError('ParseCLP constructed with a function. Did you forget ()?');\n    }\n  }\n  /**\n   * Returns a JSON-encoded version of the CLP.\n   *\n   * @returns {object}\n   */\n\n\n  (0, _createClass2.default)(ParseCLP, [{\n    key: \"toJSON\",\n    value: function toJSON()\n    /*: PermissionsMap*/\n    {\n      return _objectSpread({}, this.permissionsMap);\n    }\n    /**\n     * Returns whether this CLP is equal to another object\n     *\n     * @param other The other object to compare to\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"equals\",\n    value: function equals(other\n    /*: ParseCLP*/\n    )\n    /*: boolean*/\n    {\n      if (!(other instanceof ParseCLP)) {\n        return false;\n      }\n\n      var permissions = (0, _keys.default)(this.permissionsMap);\n      var otherPermissions = (0, _keys.default)(other.permissionsMap);\n\n      if (permissions.length !== otherPermissions.length) {\n        return false;\n      }\n\n      for (var _permission2 in this.permissionsMap) {\n        if (!other.permissionsMap[_permission2]) {\n          return false;\n        }\n\n        var users = (0, _keys.default)(this.permissionsMap[_permission2]);\n        var otherUsers = (0, _keys.default)(other.permissionsMap[_permission2]);\n\n        if (users.length !== otherUsers.length) {\n          return false;\n        }\n\n        for (var user in this.permissionsMap[_permission2]) {\n          if (!other.permissionsMap[_permission2][user]) {\n            return false;\n          }\n\n          if (this.permissionsMap[_permission2][user] !== other.permissionsMap[_permission2][user]) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_getRoleName\",\n    value: function _getRoleName(role\n    /*: ParseRole | string*/\n    )\n    /*: string*/\n    {\n      var name = role;\n\n      if (role instanceof _ParseRole.default) {\n        // Normalize to the String name\n        name = role.getName();\n      }\n\n      if (typeof name !== 'string') {\n        throw new TypeError('role must be a Parse.Role or a String');\n      }\n\n      return \"role:\".concat(name);\n    }\n  }, {\n    key: \"_parseEntity\",\n    value: function _parseEntity(entity\n    /*: Entity*/\n    ) {\n      var userId = entity;\n\n      if (userId instanceof _ParseUser.default) {\n        userId = userId.id;\n\n        if (!userId) {\n          throw new Error('Cannot get access for a Parse.User without an id.');\n        }\n      } else if (userId instanceof _ParseRole.default) {\n        userId = this._getRoleName(userId);\n      }\n\n      if (typeof userId !== 'string') {\n        throw new TypeError('userId must be a string.');\n      }\n\n      return userId;\n    }\n  }, {\n    key: \"_setAccess\",\n    value: function _setAccess(permission\n    /*: string*/\n    , userId\n    /*: Entity*/\n    , allowed\n    /*: boolean*/\n    ) {\n      userId = this._parseEntity(userId);\n\n      if (typeof allowed !== 'boolean') {\n        throw new TypeError('allowed must be either true or false.');\n      }\n\n      var permissions = this.permissionsMap[permission][userId];\n\n      if (!permissions) {\n        if (!allowed) {\n          // The user already doesn't have this permission, so no action is needed\n          return;\n        } else {\n          this.permissionsMap[permission][userId] = {};\n        }\n      }\n\n      if (allowed) {\n        this.permissionsMap[permission][userId] = true;\n      } else {\n        delete this.permissionsMap[permission][userId];\n      }\n    }\n  }, {\n    key: \"_getAccess\",\n    value: function _getAccess(permission\n    /*: string*/\n    , userId\n    /*: Entity*/\n    )\n    /*: boolean | string[]*/\n    {\n      var returnBoolean = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      userId = this._parseEntity(userId);\n      var permissions = this.permissionsMap[permission][userId];\n\n      if (returnBoolean) {\n        if (!permissions) {\n          return false;\n        }\n\n        return !!this.permissionsMap[permission][userId];\n      }\n\n      return permissions;\n    }\n  }, {\n    key: \"_setArrayAccess\",\n    value: function _setArrayAccess(permission\n    /*: string*/\n    , userId\n    /*: Entity*/\n    , fields\n    /*: string*/\n    ) {\n      userId = this._parseEntity(userId);\n      var permissions = this.permissionsMap[permission][userId];\n\n      if (!permissions) {\n        this.permissionsMap[permission][userId] = [];\n      }\n\n      if (!fields || (0, _isArray.default)(fields) && fields.length === 0) {\n        delete this.permissionsMap[permission][userId];\n      } else if ((0, _isArray.default)(fields) && (0, _every.default)(fields).call(fields, function (field) {\n        return typeof field === 'string';\n      })) {\n        this.permissionsMap[permission][userId] = fields;\n      } else {\n        throw new TypeError('fields must be an array of strings or undefined.');\n      }\n    }\n  }, {\n    key: \"_setGroupPointerPermission\",\n    value: function _setGroupPointerPermission(operation\n    /*: string*/\n    , pointerFields\n    /*: string[]*/\n    ) {\n      var fields = this.permissionsMap[operation];\n\n      if (!fields) {\n        this.permissionsMap[operation] = [];\n      }\n\n      if (!pointerFields || (0, _isArray.default)(pointerFields) && pointerFields.length === 0) {\n        delete this.permissionsMap[operation];\n      } else if ((0, _isArray.default)(pointerFields) && (0, _every.default)(pointerFields).call(pointerFields, function (field) {\n        return typeof field === 'string';\n      })) {\n        this.permissionsMap[operation] = pointerFields;\n      } else {\n        throw new TypeError(\"\".concat(operation, \".pointerFields must be an array of strings or undefined.\"));\n      }\n    }\n  }, {\n    key: \"_getGroupPointerPermissions\",\n    value: function _getGroupPointerPermissions(operation\n    /*: string*/\n    )\n    /*: string[]*/\n    {\n      return this.permissionsMap[operation];\n    }\n    /**\n     * Sets user pointer fields to allow permission for get/count/find operations.\n     *\n     * @param {string[]} pointerFields User pointer fields\n     */\n\n  }, {\n    key: \"setReadUserFields\",\n    value: function setReadUserFields(pointerFields\n    /*: string[]*/\n    ) {\n      this._setGroupPointerPermission('readUserFields', pointerFields);\n    }\n    /**\n     * @returns {string[]} User pointer fields\n     */\n\n  }, {\n    key: \"getReadUserFields\",\n    value: function getReadUserFields()\n    /*: string[]*/\n    {\n      return this._getGroupPointerPermissions('readUserFields');\n    }\n    /**\n     * Sets user pointer fields to allow permission for create/delete/update/addField operations\n     *\n     * @param {string[]} pointerFields User pointer fields\n     */\n\n  }, {\n    key: \"setWriteUserFields\",\n    value: function setWriteUserFields(pointerFields\n    /*: string[]*/\n    ) {\n      this._setGroupPointerPermission('writeUserFields', pointerFields);\n    }\n    /**\n     * @returns {string[]} User pointer fields\n     */\n\n  }, {\n    key: \"getWriteUserFields\",\n    value: function getWriteUserFields()\n    /*: string[]*/\n    {\n      return this._getGroupPointerPermissions('writeUserFields');\n    }\n    /**\n     * Sets whether the given user is allowed to retrieve fields from this class.\n     *\n     * @param userId An instance of Parse.User or its objectId.\n     * @param {string[]} fields fields to be protected\n     */\n\n  }, {\n    key: \"setProtectedFields\",\n    value: function setProtectedFields(userId\n    /*: Entity*/\n    , fields\n    /*: string[]*/\n    ) {\n      this._setArrayAccess('protectedFields', userId, fields);\n    }\n    /**\n     * Returns array of fields are accessable to this user.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n     * @returns {string[]}\n     */\n\n  }, {\n    key: \"getProtectedFields\",\n    value: function getProtectedFields(userId\n    /*: Entity*/\n    )\n    /*: string[]*/\n    {\n      return this._getAccess('protectedFields', userId, false);\n    }\n    /**\n     * Sets whether the given user is allowed to read from this class.\n     *\n     * @param userId An instance of Parse.User or its objectId.\n     * @param {boolean} allowed whether that user should have read access.\n     */\n\n  }, {\n    key: \"setReadAccess\",\n    value: function setReadAccess(userId\n    /*: Entity*/\n    , allowed\n    /*: boolean*/\n    ) {\n      this._setAccess('find', userId, allowed);\n\n      this._setAccess('get', userId, allowed);\n\n      this._setAccess('count', userId, allowed);\n    }\n    /**\n     * Get whether the given user id is *explicitly* allowed to read from this class.\n     * Even if this returns false, the user may still be able to access it if\n     * getPublicReadAccess returns true or a role that the user belongs to has\n     * write access.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"getReadAccess\",\n    value: function getReadAccess(userId\n    /*: Entity*/\n    )\n    /*: boolean*/\n    {\n      return this._getAccess('find', userId) && this._getAccess('get', userId) && this._getAccess('count', userId);\n    }\n    /**\n     * Sets whether the given user id is allowed to write to this class.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role..\n     * @param {boolean} allowed Whether that user should have write access.\n     */\n\n  }, {\n    key: \"setWriteAccess\",\n    value: function setWriteAccess(userId\n    /*: Entity*/\n    , allowed\n    /*: boolean*/\n    ) {\n      this._setAccess('create', userId, allowed);\n\n      this._setAccess('update', userId, allowed);\n\n      this._setAccess('delete', userId, allowed);\n\n      this._setAccess('addField', userId, allowed);\n    }\n    /**\n     * Gets whether the given user id is *explicitly* allowed to write to this class.\n     * Even if this returns false, the user may still be able to write it if\n     * getPublicWriteAccess returns true or a role that the user belongs to has\n     * write access.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"getWriteAccess\",\n    value: function getWriteAccess(userId\n    /*: Entity*/\n    )\n    /*: boolean*/\n    {\n      return this._getAccess('create', userId) && this._getAccess('update', userId) && this._getAccess('delete', userId) && this._getAccess('addField', userId);\n    }\n    /**\n     * Sets whether the public is allowed to read from this class.\n     *\n     * @param {boolean} allowed\n     */\n\n  }, {\n    key: \"setPublicReadAccess\",\n    value: function setPublicReadAccess(allowed\n    /*: boolean*/\n    ) {\n      this.setReadAccess(PUBLIC_KEY, allowed);\n    }\n    /**\n     * Gets whether the public is allowed to read from this class.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"getPublicReadAccess\",\n    value: function getPublicReadAccess()\n    /*: boolean*/\n    {\n      return this.getReadAccess(PUBLIC_KEY);\n    }\n    /**\n     * Sets whether the public is allowed to write to this class.\n     *\n     * @param {boolean} allowed\n     */\n\n  }, {\n    key: \"setPublicWriteAccess\",\n    value: function setPublicWriteAccess(allowed\n    /*: boolean*/\n    ) {\n      this.setWriteAccess(PUBLIC_KEY, allowed);\n    }\n    /**\n     * Gets whether the public is allowed to write to this class.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"getPublicWriteAccess\",\n    value: function getPublicWriteAccess()\n    /*: boolean*/\n    {\n      return this.getWriteAccess(PUBLIC_KEY);\n    }\n    /**\n     * Sets whether the public is allowed to protect fields in this class.\n     *\n     * @param {string[]} fields\n     */\n\n  }, {\n    key: \"setPublicProtectedFields\",\n    value: function setPublicProtectedFields(fields\n    /*: string[]*/\n    ) {\n      this.setProtectedFields(PUBLIC_KEY, fields);\n    }\n    /**\n     * Gets whether the public is allowed to read fields from this class.\n     *\n     * @returns {string[]}\n     */\n\n  }, {\n    key: \"getPublicProtectedFields\",\n    value: function getPublicProtectedFields()\n    /*: string[]*/\n    {\n      return this.getProtectedFields(PUBLIC_KEY);\n    }\n    /**\n     * Gets whether users belonging to the given role are allowed\n     * to read from this class. Even if this returns false, the role may\n     * still be able to write it if a parent role has read access.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @returns {boolean} true if the role has read access. false otherwise.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"getRoleReadAccess\",\n    value: function getRoleReadAccess(role\n    /*: ParseRole | string*/\n    )\n    /*: boolean*/\n    {\n      return this.getReadAccess(this._getRoleName(role));\n    }\n    /**\n     * Gets whether users belonging to the given role are allowed\n     * to write to this user. Even if this returns false, the role may\n     * still be able to write it if a parent role has write access.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @returns {boolean} true if the role has write access. false otherwise.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"getRoleWriteAccess\",\n    value: function getRoleWriteAccess(role\n    /*: ParseRole | string*/\n    )\n    /*: boolean*/\n    {\n      return this.getWriteAccess(this._getRoleName(role));\n    }\n    /**\n     * Sets whether users belonging to the given role are allowed\n     * to read from this class.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @param {boolean} allowed Whether the given role can read this object.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"setRoleReadAccess\",\n    value: function setRoleReadAccess(role\n    /*: ParseRole | string*/\n    , allowed\n    /*: boolean*/\n    ) {\n      this.setReadAccess(this._getRoleName(role), allowed);\n    }\n    /**\n     * Sets whether users belonging to the given role are allowed\n     * to write to this class.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @param {boolean} allowed Whether the given role can write this object.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"setRoleWriteAccess\",\n    value: function setRoleWriteAccess(role\n    /*: ParseRole | string*/\n    , allowed\n    /*: boolean*/\n    ) {\n      this.setWriteAccess(this._getRoleName(role), allowed);\n    }\n    /**\n     * Gets whether users belonging to the given role are allowed\n     * to count to this user. Even if this returns false, the role may\n     * still be able to count it if a parent role has count access.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @returns {string[]}\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"getRoleProtectedFields\",\n    value: function getRoleProtectedFields(role\n    /*: ParseRole | string*/\n    )\n    /*: string[]*/\n    {\n      return this.getProtectedFields(this._getRoleName(role));\n    }\n    /**\n     * Sets whether users belonging to the given role are allowed\n     * to set access field in this class.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @param {string[]} fields Fields to be protected by Role.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n\n  }, {\n    key: \"setRoleProtectedFields\",\n    value: function setRoleProtectedFields(role\n    /*: ParseRole | string*/\n    , fields\n    /*: string[]*/\n    ) {\n      this.setProtectedFields(this._getRoleName(role), fields);\n    }\n  }]);\n  return ParseCLP;\n}();\n\nvar _default = ParseCLP;\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}